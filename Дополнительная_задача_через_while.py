def search(self, nums, target):
        first = 0  # левая граница диапазона
        last = len(nums) -1 # правая граница диапазона

        while first<= last: 
            mid = (first + last)//2 # находим середину текущего диапазона
            if nums[mid] < target:
                first = mid +1  # если элемент посередине меньше искомого "таргет", уменьшаем диапазон до только левой части(убирая все до mid), т.к. искомое больше и соответсвенно оно находится правее.
            elif nums[mid] > target:
                last = mid -1  # если элемент посередине больше искомого "таргет", уменьшаем диапазон до только правой части(убирая все после mid), т.к. искомое меньше и соответсвенно оно находится левее.
            else:
                return mid #элемент найден -> возвращаем индекс


        return -1 #выводим -1 если элемент не найден
#асимтотическая сложность - O(logn) потому что на каждом
шаге мы делим область поиска пополам. # С каждым сравнением остаётся
только левая или правая часть массива, поэтому количество шагов
уменьшается в два раза и растёт логарифмически от размера массива # По памяти сложность O(1), так как используются только несколько
переменных для хранения границ и середины, дополнительная память не
выделяется.
